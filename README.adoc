|=======================
|Language|Build|Coverage|License|Documentation
| image:https://img.shields.io/badge/C%2B%2B-11-blue.svg[link="https://en.wikipedia.org/wiki/C%2B%2B#Standardization", title="Standard"]
| image:https://dev.azure.com/damianjarek93/canary/_apis/build/status/djarek.canary?branchName=master[link="https://dev.azure.com/damianjarek93/canary/_build/latest?definitionId=11&branchName=master", title="Build Status"]
| image:https://codecov.io/gh/djarek/canary/branch/master/graph/badge.svg[link="https://codecov.io/gh/djarek/canary", title="Coverage"]
| image:https://img.shields.io/badge/license-BSL%201.0-blue.svg[link="https://opensource.org/licenses/BSL-1.0", title="License"]
| TODO
|=======================

## Introduction

**Canary** is a thin, C++11 wrapper over the SocketCAN API in Linux, which
enables communication over https://en.wikipedia.org/wiki/CAN_bus[CAN bus] using
idioms from the https://github.com/boostorg/asio[Boost.ASIO] and
https://github.com/chriskohlhoff/asio[ASIO] libraries.

### Raw CAN frames
**Canary** exposes the raw CAN frame socket API from Linux's SocketCAN module.
When using this API, data read from the socket will contain a frame header at
the start. Users can parse it on their own, or use the provided `frame_header`
class, which is trivially copyable and can be filled by reading from the socket
directly. Note that the header is not an exact CAN frame header - the underlying
API does not expose lower-level protocol detail, such as CRCs.

### ISO-TP kernel module
**Canary** provides a wrapper for the in-kernel implementation of ISO 15765-2(also
known as ISO-TP) which is available through a kernel module,
https://github.com/hartkopp/can-isotp[see more details]. When using this
transport-layer protocol, a socket is bound to a CAN ID pair (rx, tx), often
referred to as "ISO-TP addresses". If more addresses are to be used, a socket
per (rx, tx) pair must be constructed.

NOTE: The ISO-TP kernel module must either be loaded prior to creating an ISO-TP
socket, or the module must be configured to be loaded on socket creation attempt
(using `depmod -A` after installation)

NOTE: At the time of writing, the kernel module is available out-of-tree and
needs to be built and installed separately.


== Dependencies

|=======================
|Component|Mode|Dependencies
.2+| Library | Default | Boost.ASIO
             | Standalone | ASIO

.2+| Tests (optional) | Default | Boost.Core
   |      Standalone | Boost.Core

.2+| Examples (optional) | Default | Boost.ASIO
   |      Standalone | ASIO

|=======================

=== Standalone mode
**Canary** can be configured to use standalone ASIO by defining
`CANARY_STANDALONE_ASIO`. The library provides the convenience alias
`canary::net` which refers to either `boost::asio` or `asio` in standalone mode.

## Installation
**Canary** is header-only, so you only need to add the include directory to the
include paths in your build system. An `install` target is available in CMake
which will install the headers and a CMake `find_package` configuration script
for easy consumption in projects built with CMake:

[source, bash]
----
cmake -H. -Bbuild
cmake --build build --target install
----

After installation, a project built with CMake can consume the library using
`find_package`:
[source, cmake]
----
find_package(canary REQUIRED)
target_link_libraries(my_target PUBLIC canary::canary)
----

## Running tests
Tests require the existence of 2 virtual CAN interfaces - `vcan0` and `vcan1`,
which can be created with the `create_vcans.sh` script:

[source, bash]
----
sudo tools/create_vcans.sh vcan0 vcan1
----

Tests can be run using the standard `test` target generated by CMake:

[source, bash]
----
cmake -H. -Bbuild -DBUILD_TESTING=ON -DCANARY_BUILD_COROUTINE_EXAMPLES=ON
cmake --build build --target test
----
